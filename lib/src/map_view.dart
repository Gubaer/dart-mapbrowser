part of mapbrowser;

/**
 * A browsable map view
 */
class MapView { 
  
  /// true if currently running in a firefox browser 
  static bool isFirefox() => window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
  
  CanvasElement _layer0;
  CanvasElement _layer1;
  
  int _zoom = 0;
  var _center = new LatLon.origin();  
  var _tilesource;
  PanNavigator _panNavigator;
  ZoomSlider _zoomSlider;

  /* -------------------------------- raw mouse handling -------------------------------- */
  var _lastMouseDownTimestamp = 0;
  var _lastMouseDownPos = null;
  var _mouseDown = false;
  var _isDragging = false;
  
  MyPoint _dragStart = null;
  LatLon _dragCenter = null;  
  
  _rawMouseDown(event) {
    _mouseDown = true;
    _lastMouseDownTimestamp = new Date.now().millisecondsSinceEpoch;
    _lastMouseDownPos = layerXY(event);
  }
  
  _rawMouseUp(event) {
    if (_isDragging) onDragEnd(event);
    _mouseDown = false;
    _isDragging = false; 
  }
  
  _rawMouseMove(event){
    if (_mouseDown) {
       if (!_isDragging) onDragStart(event);
      _isDragging = true;
    }
    if (_isDragging) {
      onDrag(event);
    } else {
      onMove(event);
    }
  }
  
   var deferredEvent = null;
   
  _fireDeferred() {
    if (deferredEvent != null) {
      var e = deferredEvent;
      deferredEvent = null;
      onClick(e);
    }      
  }
  
  _rawMouseClick(event) {
     if (deferredEvent == null) {
       var ts = new Date.now().millisecondsSinceEpoch;
       if (ts - _lastMouseDownTimestamp > 200) {
         // a click generated at the end of a drag sequence
         //      mouse down, mouse move, ..., mouse move, mouse up, click  
         // Ignore it.
         return;
       }
       deferredEvent = event;
       window.setTimeout(() => _fireDeferred(), 100);
     } else {
       deferredEvent = null;
       onDoubleClick(event);
     }
  }

  /* --------------------------- semantic mouse events -------------------------------- */  
  onDoubleClick(event) {
    zoomIn();
  }
  
  onClick(event) {
    _panNavigator.onClick(event);
    _zoomSlider.onClick(event);
  }
  
  onDragStart(event) {
    _dragStart = layerXY(event);
    _dragCenter = new LatLon.clone(_center);
  }
  
  onDrag(event) {
    MyPoint p = layerXY(event);
    
    var tc = tileCoordinates(_dragCenter.lat, _dragCenter.lon, _zoom);
    int tx = tc.tilePlaneX() - (p.x - _dragStart.x);    
    int ty = tc.tilePlaneY() - (p.y - _dragStart.y);
    double lon = tx/tilePlaneWidth * 360-180;    
    var n = PI-2*PI*ty/tilePlaneHeight;
    double lat = (180/PI* atan(0.5*(exp(n)-exp(-n)))); 
    _center = new LatLon(lat, lon);
    render(doClearCanvas:false);
  }  
  
  onDragEnd(event) {
    _dragStart = null;
    _dragCenter = null;
  }
  
  onMove(event) {
    _panNavigator.onMouseMove(event);
    _zoomSlider.onMouseMove(event);
  }

  onMouseWheel(event) {
    //FIXME: in M1 different signs for deltaY in native Dartium and in Firefox
    // when running JS code generated by dart2js.
    //Defect filed in http://code.google.com/p/dart/issues/detail?id=6215
    var deltaY = isFirefox() ? -event.deltaY  : event.deltaY;
    if (event.deltaY < 0) zoomOut();
    else zoomIn();
  }

  _wireListeners(layer) {
    layer.on
      ..mouseDown.add((event) => _rawMouseDown(event))
      ..mouseUp.add((event) => _rawMouseUp(event))
      ..mouseMove.add((event) => _rawMouseMove(event))
      ..click.add((event) => _rawMouseClick(event))
      ..mouseWheel.add((event) => onMouseWheel(event));
  }
  
  /* ------------------------------------------------------------------------------------ */
   
  /// event x and y converted to canvas coordinates 
  MyPoint layerXY(MouseEvent event) {
    var rect = _layer1.getBoundingClientRect(), root = document.documentElement;
    return new MyPoint(event.offsetX, event.offsetY);
  }
  
  /**
   * Creates a map viewport rendering to the canvas element
   * [canvas].
   * Optionally you may supply a [tilesource]. If missing or null, a default
   * tile source serving OSM Slippymap tiles is assumed. 
   */
  MapView(DivElement container, {tilesource: null}) {
    if (!?tilesource || tilesource == null) tilesource = new TileSource();
    assert(tilesource is TileSource);
    _tilesource = tilesource;
    
    assert(container != null);
    _layer0 = (new Element.tag("canvas") as CanvasElement);
    container.elements.add(_layer0);
    _layer0.classes.add("layer0");    
    _layer0
      ..width = _layer0.clientWidth
      ..height = _layer0.clientHeight;
          
    _layer1 = (new Element.tag("canvas") as CanvasElement);
    container.elements.add(_layer1);
    _layer1.classes.add("layer1");
    _layer1
      ..width = _layer0.width
      ..height = _layer0.height;
    
    _wireListeners(_layer1);
    render();
    
    _panNavigator = new PanNavigator(this, 40,40);
    _panNavigator.render();
    
    _zoomSlider = new ZoomSlider(this);
    _zoomSlider.render();
  }
  
  /// the layer at leven 0 (for drawing the map)
  CanvasElement get  layer0 => _layer0;
  /// the layer at level1 (for drawing decorations)
  CanvasElement  get layer1 => _layer1;
  
  get tilesource => _tilesource;
  set tilesource(source) {
    assert(source != null && source is TileSource);
    this._tilesource = source;
    render();
  }
  
  /// the with of the tile plane in pixels
  int get tilePlaneWidth => (1 << _zoom) * _tilesource.tileWidth; 
  /// the height of the tile plane in pixels
  int get tilePlaneHeight => (1 << _zoom) * _tilesource.tileHeight;  
  
  int get numXTiles => 1 << _zoom;
  int get numYTiles => 1 << _zoom;
      
  /// true if the current tile plane fits into the canvas window
  bool tilePlaneFitsIntoViewport() => tilePlaneWidth <= _layer0.width && tilePlaneHeight <= _layer0.height; 
  
  List tiles = [];
  
  renderIfTilePlaneFitsIntoViewPort() {
    int x = (_layer0.width - tilePlaneWidth) ~/ 2;
    int y = (_layer0.height - tilePlaneHeight) ~/ 2;
    for (var ti=0; ti < numXTiles; ti++) {
      for (var tj=0; tj < numYTiles; tj++) {
        Tile tile = new Tile(_zoom, ti, tj, _tilesource);
        tile.attach(_layer0.context2d, x + ti * _tilesource.tileWidth, y + tj * _tilesource.tileHeight);
        tiles.add(tile);
      }
    }
  }
  
  renderIfTileDoesntFitIntoViewPort() {
    bindLoadCallback(image, x, y) {
      return (event) {
        _layer0.context2d.drawImage(image, x, y);               
      };
    };
    var coor  = tileCoordinates(_center.lat, _center.lon, _zoom);
    int x = _layer0.width ~/ 2 - coor.dx;
    int y = _layer0.height ~/ 2 - coor.dy;
    int ti = coor.ti;
    int tj = coor.tj;
    while(x > 0 && ti > 0) {x-= _tilesource.tileWidth; ti--;}
    while(y > 0 && tj > 0) {y-= _tilesource.tileHeight; tj--;}      
    int x0 = x, y0 = y, ti0 = ti, tj0 = tj;
    while(y < _layer0.height) {
      while(x < _layer0.width) {
        Tile tile = new Tile(_zoom, ti, tj, _tilesource);
        tile.attach(_layer0.context2d, x, y);
        tiles.add(tile);
        x+=_tilesource.tileWidth;ti++;
      }
      x=x0; ti=ti0;y+=_tilesource.tileHeight;tj++;
    }
  }
  
  render({bool doClearCanvas: true}) {
    tiles.forEach((tile) => tile.detach());
    tiles = [];
    if (doClearCanvas) {
      _layer0.context2d.setFillColorRgb(255, 255, 255,255);
      _layer0.context2d.fillRect(0,0, _layer0.width, _layer0.height);
    }
    if (tilePlaneFitsIntoViewport()) {
      renderIfTilePlaneFitsIntoViewPort();
    } else {      
      renderIfTileDoesntFitIntoViewPort();
    }    
  }
  
  /* --------------------- zooming -------------------------------------- */  
  ///  get current zoom leven
  int get zoom => _zoom;
  
  /// set zoom level to [value]. Expected: > 0 and <= max zoom level for the
  /// current tile source 
  set zoom(int value) {
    _zoom = value; //TODO: argument check
    render();
  }
 
  /// zoom in by [levels] steps 
  zoomIn([int levels=1]) {
    _zoom = min(_zoom + levels, _tilesource.zoomLevels); 
    render();
  }
  
  /// zoom out by [levels] steps 
  zoomOut([int levels=1]) {
    _zoom = max(_zoom - levels, 0); 
    render();
  }
  
  /**
   * Tile cordinates for the pixel in the tile plane at zoom level
   * [zoom] at ([lat], [lon])
   */
  TileCoordinates tileCoordinates(num lat, num lon, int zoom) {
    int xx = ((lon + 180) / 360 * tilePlaneWidth).floor().toInt();
    int yy = ((1-log(tan(lat*PI/180) + 1/cos(lat*PI/180))/PI)/2 *tilePlaneHeight).floor().toInt();
    return new TileCoordinates(
      ti: xx ~/ _tilesource.tileWidth, 
      tj: yy ~/ _tilesource.tileHeight,
      dx: xx % _tilesource.tileWidth,
      dy: yy % _tilesource.tileHeight
    );
  }
  
  /* -------------------------------------------------------------------------------------- */
  _panMoveTo(x,y,dx, dy) {
    var sx = dx ~/ 10;
    var sy = dy ~/ 10;
    
    makeRenderer(lat,lon) {
      return () {
        _center = new LatLon(lat,lon);
        render();
      };
    }
    for (int i=1; i<=10; i++ ) {
      var nx =  x + i * sx;
      if (dx > 0) nx =  min(x + dx, nx);
      else if (dx < 0) nx = max(x + dx, nx);
      
      var ny = y + i * sy;
      if (dy > 0) nx =  min(y + dy, nx);
      else if (dy < 0) nx = max(y + dy, nx);
      
      double lon = nx/tilePlaneWidth * 360-180;    
      var n = PI-2*PI*ny/tilePlaneHeight;
      double lat = (180/PI* atan(0.5*(exp(n)-exp(-n))));
      var renderer = makeRenderer(lat,lon);
      window.setTimeout(renderer, 50 * i);
    }
  }
  
  panUp() {
     var tc = tileCoordinates(_center.lat, _center.lon, zoom);
     var x = tc.tilePlaneX(this._tilesource);
     var y = tc.tilePlaneY(this._tilesource);
     _panMoveTo(x,y, 0, -200);
  }
  
  panDown() {
     var tc = tileCoordinates(_center.lat, _center.lon, zoom);
     var x = tc.tilePlaneX(this._tilesource);
     var y = tc.tilePlaneY(this._tilesource);
     _panMoveTo(x,y, 0,200);
  }
  
  panRight() {
    var tc = tileCoordinates(_center.lat, _center.lon, zoom);
    var x = tc.tilePlaneX(this._tilesource) + 100;
    var y = tc.tilePlaneY(this._tilesource);
    _panMoveTo(x,y,200,0);
  }
  
  panLeft() {
    var tc = tileCoordinates(_center.lat, _center.lon, zoom);
    var x = tc.tilePlaneX(this._tilesource) - 100;
    var y = tc.tilePlaneY(this._tilesource);
    _panMoveTo(x,y,-200,0);
  }
  
  setPointerCursor() => _layer1.style.cursor = "pointer";
  setDefaultCursor() => _layer1.style.cursor = "default";
}

class RectangularArea {
  int x,y, width, height;
  RectangularArea(this.x, this.y, this.width, this.height);
  
  translate(dx, dy) {
    return new RectangularArea(x + dx, y + dy, width, height);
  }
  
  isInside(p) {
    return p.x >= this.x && p.x < this.x + this.width
        && p.y >= this.y && p.y <  this.y + this.height;
  }
    
  MyPoint get center =>  new MyPoint (x + width ~/ 2, y + height ~/ 2);
}

class RespondingRectangularArea extends RectangularArea {
  var onEnter;
  var onExit;
  var mouseOver = false;
  RespondingRectangularArea(int x, int y, int width, int height, {onEnter:null, onExit:null}) : super(x,y,width,height) {
    this.onEnter = onEnter;
    this.onExit = onExit;
  }
  
  onMouseMove(p) {
    var inside = isInside(p);
    if (inside && !mouseOver) {
       if (onEnter != null) onEnter();
       mouseOver = true;
    } else if (!inside && mouseOver) {
      if (onExit != null) onExit();
      mouseOver = false;
    }
  }
}

class ZoomNob extends RespondingRectangularArea{
   MapView parent;
   ZoomNob(parent, int x, int y, int width, int height) 
      : super(x,y,width, height, onEnter: parent.setPointerCursor, onExit: parent.setDefaultCursor) {
      this.parent = parent;     
   }
   
   ZoomNob.other(parent, RectangularArea r) : this(parent, r.x, r.y, r.width, r.height);
   
   render(CanvasRenderingContext2D ctx) {
     var shadow = translate(3, 3);
     ctx.setFillColorRgb(120, 120, 120);
     ctx.lineWidth = 0;
     _renderRect(ctx, shadow);
     ctx.setFillColorRgb(255,255,255); 
     ctx.lineWidth = 1;
     ctx.strokeStyle = "rgb(50,50,50)";
     ctx.lineWidth = 1;
     _renderRect(ctx,this);
   }
   
   _renderRect(CanvasRenderingContext2D ctx, RectangularArea r) {
     ctx.beginPath();
     ctx.moveTo(r.x, r.y);
     ctx.lineTo(r.x+r.width, r.y);
     ctx.lineTo(r.x+r.width, r.y+r.height);
     ctx.lineTo(r.x, r.y+r.height);
     ctx.closePath();
     ctx.stroke();
     ctx.fill();
   }
        
   renderPlus(CanvasRenderingContext2D ctx) {
     ctx
       ..strokeStyle = "rgb(100,100,100)"
       ..lineWidth = 3
       ..lineCap = "round";
     
     ctx
      ..beginPath()
      ..moveTo(x + 5, y + 10)
      ..lineTo(x + 15, y + 10)
      ..stroke();
     
     ctx
     ..beginPath()
     ..moveTo(x + 10, y + 5)
     ..lineTo(x + 10, y + 15)
     ..stroke();     
   }
   
   renderMinus(CanvasRenderingContext2D ctx) {
      ctx
       ..strokeStyle = "rgb(100,100,100)"
       ..lineWidth = 3
       ..lineCap = "round";
     
     ctx
      ..beginPath()
      ..moveTo(x + 5, y + 10)
      ..lineTo(x + 15, y + 10)
      ..stroke();
   }
}

class ZoomSlider {
  
  MapView _parent;
  
  ZoomNob plus;
  ZoomNob minus;
  
  ZoomSlider(this._parent) {
    plus = new ZoomNob(_parent,30,90,20,20);
    minus = new ZoomNob.other(_parent, plus.translate(0, 200));    
  }
  
  _renderZoomNob(ctx, r) {
    var shadow = r.translate(3, 3);
    ctx.setFillColorRgb(120, 120, 120);
    ctx.lineWidth = 0;
    shadow.render(ctx);
    ctx.setFillColorRgb(255,255,255); 
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgb(50,50,50)";
    ctx.lineWidth = 1;
    r.render(ctx);
  }
  
  _renderZoomSlider(ctx) {
     var c1 = plus.center;
     var c2 = minus.center;
     ctx.beginPath();
     ctx.moveTo(c1.x, c1.y);
     ctx.lineTo(c2.x, c2.y);
     ctx.strokeStyle = "rgba(150,150,150, 0.7)";
     ctx.lineWidth = 5;
     ctx.stroke();
  }
  
  render() {
    var ctx = _parent.layer1.context2d;
    ctx.save();    
    _renderZoomSlider(ctx);
    plus.render(ctx);
    plus.renderPlus(ctx);
    minus.render(ctx);
    minus.renderMinus(ctx);
    ctx.restore();
  }
  
  onMouseMove(event) {
    var p = _parent.layerXY(event);
    plus.onMouseMove(p);
    minus.onMouseMove(p);
  }
  
  onClick(event) {
    var p = _parent.layerXY(event);
    if (plus.isInside(p)) _parent.zoomIn();
    else if (minus.isInside(p)) _parent.zoomOut();
  }
}

class PanNavigator {
  static const RADIUS = 25;
      
  var up, right, down, left; 
   
  int _x;
  int _y; 
  MapView _parent;
  bool _mouseOver = false;
  
  PanNavigator(MapView this._parent, this._x, this._y) {
    up = new RespondingRectangularArea(35, 20, 10, 5, onEnter: _parent.setPointerCursor, onExit: _parent.setDefaultCursor);
    right = new RespondingRectangularArea(55, 35, 5, 10, onEnter: _parent.setPointerCursor, onExit: _parent.setDefaultCursor);
    left= new RespondingRectangularArea(20, 35, 5, 10,onEnter: _parent.setPointerCursor, onExit: _parent.setDefaultCursor);
    down= new RespondingRectangularArea(35, 55, 10, 5,onEnter: _parent.setPointerCursor, onExit: _parent.setDefaultCursor);
  }
  
  render() {
    var ctx = _parent.layer1.context2d;
    ctx.beginPath();
    ctx.arc(_x, _y, RADIUS, 0, 2 * PI, false);
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#848282";
    if (_mouseOver) {
      ctx.fillStyle = "rgba(240,240,240,1.0)";
    } else {
      ctx.fillStyle = "rgba(255,255,255,0.8)";      
    }
    ctx.fill();
    ctx.stroke();    

    ctx.save();
    ctx.translate(_x, _y);   
    ctx.strokeStyle = "#848282";
    ctx.fillStyle = "#848282";
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    double angle = 0.0;
    while(angle < 2 * PI) {
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(0,-20);
      ctx.lineTo(5,-15);
      ctx.lineTo(-5,-15);
      ctx.closePath();
      ctx.stroke();
      ctx.fill();
      angle += PI / 2;
    }
    ctx.restore();
  }
  
  bool isInside(event) {
    var p = _parent.layerXY(event);
    var dist = sqrt(pow(_x - p.x, 2) + pow(_y - p.y, 2));
    return dist <= RADIUS;
  }
  
  onMouseMove(event) {
    var hit = isInside(event);
    var p = _parent.layerXY(event);
    if (hit && !_mouseOver) {
      _mouseOver = true;
      render();
    } else if (!hit && _mouseOver) {
      _mouseOver = false;
      render();
    }  
    up.onMouseMove(p);
    right.onMouseMove(p);
    down.onMouseMove(p);
    left.onMouseMove(p);
  }
  
  onClick(event) {
    MyPoint p = _parent.layerXY(event);
    if (up.isInside(p)) _parent.panUp();
    else if (right.isInside(p)) _parent.panRight();
    else if (down.isInside(p)) _parent.panDown();
    else if (left.isInside(p)) _parent.panLeft();
  } 
}

class MyPoint {
   int x, y;
   MyPoint(this.x, this.y);   
   toString() => "MyPoint{x:$x, y: $y";
}
