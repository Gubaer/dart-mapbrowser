part of mapbrowser;

/**
 * A browsable map view
 */
class MapView { 
  
  /// true if currently running in a firefox browser 
  static bool isFirefox() => window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
  
  CanvasElement _canvas;
  CanvasRenderingContext2D _context;  
  int _zoom = 0;
  var _center = new LatLon.origin();  
  var _tilesource;
 
  
  bool dragging = false;
  //FIXME: can't use Point from dart:html in M1. Doesn't work in JS generated
  //by dart2js.
  MyPoint dragStart = null;
  LatLon dragCenter = null;  
  onMouseDown(event){
    this.dragStart = new MyPoint(
       event.pageX - _canvas.offsetLeft,
       event.pageY - _canvas.offsetTop
    );
    dragCenter = new LatLon.clone(_center);
  }
  
  onMouseUp(event) {    
    dragStart = null;
  }
  
  onMouseMove(event) {
    if (this.dragStart == null) return;
    int x = event.pageX - _canvas.offsetLeft;
    int y = event.pageY - _canvas.offsetTop;
    
    var tc = tileCoordinates(dragCenter.lat, dragCenter.lon, _zoom);
    int tx = tc.tilePlaneX() - (x - dragStart.x.toInt());    
    int ty = tc.tilePlaneY() - (y - dragStart.y.toInt());
    double lon = tx/tilePlaneWidth * 360-180;    
    var n = PI-2*PI*ty/tilePlaneHeight;
    double lat = (180/PI* atan(0.5*(exp(n)-exp(-n)))); 
    _center = new LatLon(lat, lon);
    render(doClearCanvas:false);
  }
  
  onMouseWheel(event) {
    //FIXME: in M1 different signs for deltaY in native Dartium and in Firefox
    // when running JS code generated by dart2js.
    if (isFirefox()) {      
      if (event.deltaY < 0) zoomIn();
      else if (event.deltaY > 0) zoomOut();      
    } else {
      if (event.deltaY > 0) zoomIn();
      else if (event.deltaY < 0) zoomOut();
    }
  }

  /**
   * Creates a map viewport rendering to the canvas element
   * [canvas].
   * Optionally you may supply a [tilesource]. If missing or null, a default
   * tile source serving OSM Slippymap tiles is assumed. 
   */
  MapView(CanvasElement canvas, {tilesource: null}) {
    if (!?tilesource || tilesource == null) tilesource = new TileSource();
    assert(tilesource is TileSource);
    _tilesource = tilesource;
    
    assert(canvas is CanvasElement);
    _canvas = canvas;
    _context = _canvas.context2d;
    
    _canvas
      ..width = _canvas.clientWidth
      ..height = _canvas.clientHeight;
    
    _canvas.on
      ..doubleClick.add((event) => zoomIn())
      ..mouseDown.add((event) => onMouseDown(event))
      ..mouseUp.add((event) => onMouseUp(event))
      ..mouseMove.add((event) => onMouseMove(event))
      ..mouseWheel.add((event) => onMouseWheel(event));
      
    render();
  }
  
  /// the with of the tile plane in pixels
  int get tilePlaneWidth => (1 << _zoom) * _tilesource.tileWidth; 
  /// the height of the tile plane in pixels
  int get tilePlaneHeight => (1 << _zoom) * _tilesource.tileHeight;  
  
  int get numXTiles => 1 << _zoom;
  int get numYTiles => 1 << _zoom;
      
  /// true if the current tile plane fits into the canvas window
  bool tilePlaneFitsIntoViewport() => tilePlaneWidth <= _canvas.width && tilePlaneHeight <= _canvas.height; 
  
  List tiles = [];
  
  renderIfTilePlaneFitsIntoViewPort() {
    int x = (_canvas.width - tilePlaneWidth) ~/ 2;
    int y = (_canvas.height - tilePlaneHeight) ~/ 2;
    for (var ti=0; ti < numXTiles; ti++) {
      for (var tj=0; tj < numYTiles; tj++) {
        Tile tile = new Tile(_zoom, ti, tj, _tilesource);
        tile.attach(_context, x + ti * _tilesource.tileWidth, y + tj * _tilesource.tileHeight);
        tiles.add(tile);
      }
    }
  }
  
  renderIfTileDoesntFitIntoViewPort() {
    bindLoadCallback(image, x, y) {
      return (event) {
        _context.drawImage(image, x, y);               
      };
    };
    var coor  = tileCoordinates(_center.lat, _center.lon, _zoom);
    int x = _canvas.width ~/ 2 - coor.dx;
    int y = _canvas.height ~/ 2 - coor.dy;
    int ti = coor.ti;
    int tj = coor.tj;
    while(x > 0 && ti > 0) {x-= _tilesource.tileWidth; ti--;}
    while(y > 0 && tj > 0) {y-= _tilesource.tileHeight; tj--;}      
    int x0 = x, y0 = y, ti0 = ti, tj0 = tj;
    while(y < _canvas.height) {
      while(x < _canvas.width) {
        Tile tile = new Tile(_zoom, ti, tj, _tilesource);
        tile.attach(_context, x, y);
        tiles.add(tile);
        x+=_tilesource.tileWidth;ti++;
      }
      x=x0; ti=ti0;y+=_tilesource.tileHeight;tj++;
    }
  }
  
  render({bool doClearCanvas: true}) {
    tiles.forEach((tile) => tile.detach());
    tiles = [];
    if (doClearCanvas) {
      _context.setFillColorRgb(255, 255, 255,255);
      _context.fillRect(0,0, _canvas.width, _canvas.height);
    }
    if (tilePlaneFitsIntoViewport()) {
      renderIfTilePlaneFitsIntoViewPort();
    } else {      
      renderIfTileDoesntFitIntoViewPort();
    }        
  }
  
  /* --------------------- zooming -------------------------------------- */  
  ///  get current zoom leven
  int get zoom => _zoom;
  
  /// set zoom level to [value]. Expected: > 0 and <= max zoom level for the
  /// current tile source 
  set zoom(int value) {
    _zoom = value; //TODO: argument check
    render();
  }
 
  /// zoom in by [levels] steps 
  zoomIn([int levels=1]) {
    _zoom = min(_zoom + levels, _tilesource.zoomLevels); 
    render();
  }
  
  /// zoom out by [levels] steps 
  zoomOut([int levels=1]) {
    _zoom = max(_zoom - levels, 0); 
    render();
  }
  
  /**
   * Tile cordinates for the pixel in the tile plane at zoom level
   * [zoom] at ([lat], [lon])
   */
  TileCoordinates tileCoordinates(num lat, num lon, int zoom) {
    int xx = ((lon + 180) / 360 * tilePlaneWidth).floor().toInt();
    int yy = ((1-log(tan(lat*PI/180) + 1/cos(lat*PI/180))/PI)/2 *tilePlaneHeight).floor().toInt();
    return new TileCoordinates(
      ti: xx ~/ _tilesource.tileWidth, 
      tj: yy ~/ _tilesource.tileHeight,
      dx: xx % _tilesource.tileWidth,
      dy: yy % _tilesource.tileHeight
    );
  }
}

class MyPoint {
   int x, y;
   MyPoint(this.x, this.y);
}
