part of mapbrowser;

/**
 * Renders a tiled map.
 */
class TileLayer extends Layer {
  
  TileSource _tilesource;
  var _tiles = [];
  
  /// creates a new tile layer for tile source [tilesource]. If [tilesource]
  /// is missing or null, creates a tile layer for the default tile source.
  TileLayer(Viewport viewport, [TileSource tilesource=null]): super(viewport){
    if (tilesource == null) tilesource = new TileSource();
    assert(tilesource is TileSource);
    _tilesource = tilesource;
    
    render();
    repaint();
  }
  
  /// the with of the tile plane in pixels
  int get tilePlaneWidth => (1 << _viewport.zoom) * _tilesource.tileWidth; 
  
  /// the height of the tile plane in pixels
  int get tilePlaneHeight => (1 << _viewport.zoom) * _tilesource.tileHeight;  
  
  /// # tiles in the x-axis on the current zoom level
  int get numXTiles => 1 << _viewport.zoom;
  
  /// # tiles in the y-axis on the current zoom level 
  int get numYTiles => 1 << _viewport.zoom;
  
  /// true if the current tile plane fits into the canvas window
  bool get tilePlaneFitsIntoViewport => tilePlaneWidth <= width && tilePlaneHeight <= height; 
  
  set tilesource(TileSource value) {
    assert(value != null);
    this._tilesource = value;
    render();
    repaint();
  }
  
  /**
   * Tile cordinates for the pixel in the tile plane at zoom level
   * [zoom] at ([lat], [lon])
   */
  TileCoordinates tileCoordinates(num lat, num lon, int zoom) {
    int xx = ((lon + 180) / 360 * tilePlaneWidth).floor().toInt();
    int yy = ((1-log(tan(lat*PI/180) + 1/cos(lat*PI/180))/PI)/2 *tilePlaneHeight).floor().toInt();
    return new TileCoordinates(
      ti: xx ~/ _tilesource.tileWidth, 
      tj: yy ~/ _tilesource.tileHeight,
      dx: xx % _tilesource.tileWidth,
      dy: yy % _tilesource.tileHeight
    );
  }
  
  _renderIfTilePlaneFitsIntoViewPort() {
    int x = (width - tilePlaneWidth) ~/ 2;
    int y = (height - tilePlaneHeight) ~/ 2;
    for (var ti=0; ti < numXTiles; ti++) {
      for (var tj=0; tj < numYTiles; tj++) {
        Tile tile = new Tile(_viewport.zoom, ti, tj, _tilesource);
        tile.attach(this, x + ti * _tilesource.tileWidth, y + tj * _tilesource.tileHeight);
        _tiles.add(tile);
      }
    }
  }
  
  int get _zoom => _viewport.zoom;
  int get max_ti =>  (1 << _zoom) - 1;
  int get max_tj =>  (1 << _zoom) - 1;
    
  _renderIfTileDoesntFitIntoViewPort() {
    var coor  = tileCoordinates(_viewport.center.lat, _viewport.center.lon, _viewport.zoom);
    int x = width ~/ 2 - coor.dx;
    int y = height ~/ 2 - coor.dy;
    int ti = coor.ti;
    int tj = coor.tj;
    while(x > 0 && ti > 0) {x-= _tilesource.tileWidth; ti--;}
    while(y > 0 && tj > 0) {y-= _tilesource.tileHeight; tj--;}      
    int x0 = x, y0 = y, ti0 = ti, tj0 = tj;
    while(y < height) {
      while(x < width) {
        if (ti <= max_ti && tj <= max_tj) {
          Tile tile = new Tile(_viewport.zoom, ti, tj, _tilesource);
          tile.attach(this, x, y);
          _tiles.add(tile);
        }
        x+=_tilesource.tileWidth;ti++;
      }
      x=x0; ti=ti0;y+=_tilesource.tileHeight;tj++;
    }
  }
  
  _renderNoSuchZoomLevel() {
    gc
      ..font = '14pt Calibri'
      ..textAlign = 'center'
      ..textBaseline = 'middle'
      ..fillStyle = 'rgb(180,180,180)'
      ..fillText("No map tiles at this zoom level.", width ~/ 2 , height ~/ 2);       
  }
  
  render() {    
    // clear background 
    gc.setFillColorRgb(255, 255,255); // white
    gc.fillRect(0, 0, width, height);
    _tiles.forEach((tile) => tile.detach());
    _tiles = [];
    
    if (viewport.zoom > _tilesource.zoomLevels) {
      _renderNoSuchZoomLevel();
    }
    
    // render the tiles
    if (tilePlaneFitsIntoViewport) {
      _renderIfTilePlaneFitsIntoViewPort();
    } else {      
      _renderIfTileDoesntFitIntoViewPort();
    }    
  }
  
  onMouseWheel(event) {
    //FIXME: in M1 different signs for deltaY in native Dartium and in Firefox
    // when running JS code generated by dart2js.
    //Defect filed in http://code.google.com/p/dart/issues/detail?id=6215
    var deltaY = isFirefox ? -event.deltaY  : event.deltaY;
    if (deltaY < 0) _viewport.zoomOut();
    else _viewport.zoomIn();
  }
  
  onDoubleClick(event) {
    _viewport.zoomIn();
  }
  
  //FIXME: declaration with type 'Point' leads to a run time error. 
  // why??
  //Point _dragStart = null;  
  var _dragStart = null;
  var _dragLast = null;
  var _dragLastTimestamp = null;
  var _dragDirection = null;
  double _dragVelocity = 0.0;
  LatLon _dragCenter = null;  

  onDragStart(event) {
    _dragStart = new Point.offset(event);
    _dragCenter = new LatLon.clone(_viewport.center);
    _viewport.cursor = "move";
  }
  
  onMouseDrag(event) {
    Point p = new Point.offset(event);    
    if (_dragLast != null) {
      var dist = _dragLast.distance(p);
      int dt = event.timeStamp - _dragLastTimestamp;
      _dragVelocity = dt > 0 ? dist / dt : 0.0;
      _dragDirection = (p - _dragLast).theta;
    }
    _dragLast = new Point.clone(p);
    _dragLastTimestamp = event.timeStamp;
    
    _pan(_dragCenter, _dragStart.x - p.x, _dragStart.y - p.y);    
    render();
  }  
  
  _pan(LatLon relativeTo, dx, dy) {
    var tc = tileCoordinates(relativeTo.lat, relativeTo.lon, _viewport.zoom);
    int tx = tc.tilePlaneX() + dx;    
    int ty = tc.tilePlaneY() + dy;
    if (! tilePlaneFitsIntoViewport) {
      tx = max(_viewport.width ~/ 2, tx);
      ty = max(_viewport.height ~/ 2, ty);
      tx = min(tilePlaneWidth - _viewport.width ~/ 2, tx);
      ty = min(tilePlaneHeight - _viewport.height ~/ 2, ty);
    }
    double lon = tx/tilePlaneWidth * 360-180;    
    var n = PI-2*PI*ty/tilePlaneHeight;
    double lat = (180/PI* atan(0.5*(exp(n)-exp(-n)))); 
    _viewport.center = new LatLon(lat,lon);
  }
  
  onDragEnd(event) {    
    _viewport.cursor = "default";
    
    createAnimationStep(delta) => (timer){
      _pan(_viewport.center, -delta.x, -delta.y);
      render();
    };
    Point p = new Point.offset(event); 
    if (_dragLast == null || _dragLastTimestamp == null) return;
    var v = _dragVelocity;
    var delay = 50;
    while(v > 0){
      var dist = v * 50;              /* dist = v * t */
      var next = new Point.polar(dist, _dragDirection);
      v -= 0.3;                      /* v = a * t */
      new Timer(delay, createAnimationStep(next));
      delay += 50;
    }
    _dragStart = null;
    _dragCenter = null;    
  }  
}